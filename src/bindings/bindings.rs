/* automatically generated by rust-bindgen 0.69.2 */

pub const EXIF_TAG_GPS_VERSION_ID: u32 = 0;
pub const EXIF_TAG_GPS_LATITUDE_REF: u32 = 1;
pub const EXIF_TAG_GPS_LATITUDE: u32 = 2;
pub const EXIF_TAG_GPS_LONGITUDE_REF: u32 = 3;
pub const EXIF_TAG_GPS_LONGITUDE: u32 = 4;
pub const EXIF_TAG_GPS_ALTITUDE_REF: u32 = 5;
pub const EXIF_TAG_GPS_ALTITUDE: u32 = 6;
pub const EXIF_TAG_GPS_TIME_STAMP: u32 = 7;
pub const EXIF_TAG_GPS_SATELLITES: u32 = 8;
pub const EXIF_TAG_GPS_STATUS: u32 = 9;
pub const EXIF_TAG_GPS_MEASURE_MODE: u32 = 10;
pub const EXIF_TAG_GPS_DOP: u32 = 11;
pub const EXIF_TAG_GPS_SPEED_REF: u32 = 12;
pub const EXIF_TAG_GPS_SPEED: u32 = 13;
pub const EXIF_TAG_GPS_TRACK_REF: u32 = 14;
pub const EXIF_TAG_GPS_TRACK: u32 = 15;
pub const EXIF_TAG_GPS_IMG_DIRECTION_REF: u32 = 16;
pub const EXIF_TAG_GPS_IMG_DIRECTION: u32 = 17;
pub const EXIF_TAG_GPS_MAP_DATUM: u32 = 18;
pub const EXIF_TAG_GPS_DEST_LATITUDE_REF: u32 = 19;
pub const EXIF_TAG_GPS_DEST_LATITUDE: u32 = 20;
pub const EXIF_TAG_GPS_DEST_LONGITUDE_REF: u32 = 21;
pub const EXIF_TAG_GPS_DEST_LONGITUDE: u32 = 22;
pub const EXIF_TAG_GPS_DEST_BEARING_REF: u32 = 23;
pub const EXIF_TAG_GPS_DEST_BEARING: u32 = 24;
pub const EXIF_TAG_GPS_DEST_DISTANCE_REF: u32 = 25;
pub const EXIF_TAG_GPS_DEST_DISTANCE: u32 = 26;
pub const EXIF_TAG_GPS_PROCESSING_METHOD: u32 = 27;
pub const EXIF_TAG_GPS_AREA_INFORMATION: u32 = 28;
pub const EXIF_TAG_GPS_DATE_STAMP: u32 = 29;
pub const EXIF_TAG_GPS_DIFFERENTIAL: u32 = 30;
pub const EXIF_TAG_GPS_H_POSITIONING_ERROR: u32 = 31;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __GNUC_VA_LIST: u32 = 1;
pub const ExifIfd_EXIF_IFD_0: ExifIfd = 0;
pub const ExifIfd_EXIF_IFD_1: ExifIfd = 1;
pub const ExifIfd_EXIF_IFD_EXIF: ExifIfd = 2;
pub const ExifIfd_EXIF_IFD_GPS: ExifIfd = 3;
pub const ExifIfd_EXIF_IFD_INTEROPERABILITY: ExifIfd = 4;
pub const ExifIfd_EXIF_IFD_COUNT: ExifIfd = 5;
pub type ExifIfd = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_ifd_get_name(ifd: ExifIfd) -> *const ::std::os::raw::c_char;
}
pub const ExifDataType_EXIF_DATA_TYPE_UNCOMPRESSED_CHUNKY: ExifDataType = 0;
pub const ExifDataType_EXIF_DATA_TYPE_UNCOMPRESSED_PLANAR: ExifDataType = 1;
pub const ExifDataType_EXIF_DATA_TYPE_UNCOMPRESSED_YCC: ExifDataType = 2;
pub const ExifDataType_EXIF_DATA_TYPE_COMPRESSED: ExifDataType = 3;
pub const ExifDataType_EXIF_DATA_TYPE_COUNT: ExifDataType = 4;
pub const ExifDataType_EXIF_DATA_TYPE_UNKNOWN: ExifDataType = 4;
pub type ExifDataType = ::std::os::raw::c_uint;
pub const ExifTag_EXIF_TAG_INTEROPERABILITY_INDEX: ExifTag = 1;
pub const ExifTag_EXIF_TAG_INTEROPERABILITY_VERSION: ExifTag = 2;
pub const ExifTag_EXIF_TAG_NEW_SUBFILE_TYPE: ExifTag = 254;
pub const ExifTag_EXIF_TAG_IMAGE_WIDTH: ExifTag = 256;
pub const ExifTag_EXIF_TAG_IMAGE_LENGTH: ExifTag = 257;
pub const ExifTag_EXIF_TAG_BITS_PER_SAMPLE: ExifTag = 258;
pub const ExifTag_EXIF_TAG_COMPRESSION: ExifTag = 259;
pub const ExifTag_EXIF_TAG_PHOTOMETRIC_INTERPRETATION: ExifTag = 262;
pub const ExifTag_EXIF_TAG_FILL_ORDER: ExifTag = 266;
pub const ExifTag_EXIF_TAG_DOCUMENT_NAME: ExifTag = 269;
pub const ExifTag_EXIF_TAG_IMAGE_DESCRIPTION: ExifTag = 270;
pub const ExifTag_EXIF_TAG_MAKE: ExifTag = 271;
pub const ExifTag_EXIF_TAG_MODEL: ExifTag = 272;
pub const ExifTag_EXIF_TAG_STRIP_OFFSETS: ExifTag = 273;
pub const ExifTag_EXIF_TAG_ORIENTATION: ExifTag = 274;
pub const ExifTag_EXIF_TAG_SAMPLES_PER_PIXEL: ExifTag = 277;
pub const ExifTag_EXIF_TAG_ROWS_PER_STRIP: ExifTag = 278;
pub const ExifTag_EXIF_TAG_STRIP_BYTE_COUNTS: ExifTag = 279;
pub const ExifTag_EXIF_TAG_X_RESOLUTION: ExifTag = 282;
pub const ExifTag_EXIF_TAG_Y_RESOLUTION: ExifTag = 283;
pub const ExifTag_EXIF_TAG_PLANAR_CONFIGURATION: ExifTag = 284;
pub const ExifTag_EXIF_TAG_RESOLUTION_UNIT: ExifTag = 296;
pub const ExifTag_EXIF_TAG_TRANSFER_FUNCTION: ExifTag = 301;
pub const ExifTag_EXIF_TAG_SOFTWARE: ExifTag = 305;
pub const ExifTag_EXIF_TAG_DATE_TIME: ExifTag = 306;
pub const ExifTag_EXIF_TAG_ARTIST: ExifTag = 315;
pub const ExifTag_EXIF_TAG_WHITE_POINT: ExifTag = 318;
pub const ExifTag_EXIF_TAG_PRIMARY_CHROMATICITIES: ExifTag = 319;
pub const ExifTag_EXIF_TAG_SUB_IFDS: ExifTag = 330;
pub const ExifTag_EXIF_TAG_TRANSFER_RANGE: ExifTag = 342;
pub const ExifTag_EXIF_TAG_JPEG_PROC: ExifTag = 512;
pub const ExifTag_EXIF_TAG_JPEG_INTERCHANGE_FORMAT: ExifTag = 513;
pub const ExifTag_EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH: ExifTag = 514;
pub const ExifTag_EXIF_TAG_YCBCR_COEFFICIENTS: ExifTag = 529;
pub const ExifTag_EXIF_TAG_YCBCR_SUB_SAMPLING: ExifTag = 530;
pub const ExifTag_EXIF_TAG_YCBCR_POSITIONING: ExifTag = 531;
pub const ExifTag_EXIF_TAG_REFERENCE_BLACK_WHITE: ExifTag = 532;
pub const ExifTag_EXIF_TAG_XML_PACKET: ExifTag = 700;
pub const ExifTag_EXIF_TAG_RELATED_IMAGE_FILE_FORMAT: ExifTag = 4096;
pub const ExifTag_EXIF_TAG_RELATED_IMAGE_WIDTH: ExifTag = 4097;
pub const ExifTag_EXIF_TAG_RELATED_IMAGE_LENGTH: ExifTag = 4098;
pub const ExifTag_EXIF_TAG_IMAGE_DEPTH: ExifTag = 32997;
pub const ExifTag_EXIF_TAG_CFA_REPEAT_PATTERN_DIM: ExifTag = 33421;
pub const ExifTag_EXIF_TAG_CFA_PATTERN: ExifTag = 33422;
pub const ExifTag_EXIF_TAG_BATTERY_LEVEL: ExifTag = 33423;
pub const ExifTag_EXIF_TAG_COPYRIGHT: ExifTag = 33432;
pub const ExifTag_EXIF_TAG_EXPOSURE_TIME: ExifTag = 33434;
pub const ExifTag_EXIF_TAG_FNUMBER: ExifTag = 33437;
pub const ExifTag_EXIF_TAG_IPTC_NAA: ExifTag = 33723;
pub const ExifTag_EXIF_TAG_IMAGE_RESOURCES: ExifTag = 34377;
pub const ExifTag_EXIF_TAG_EXIF_IFD_POINTER: ExifTag = 34665;
pub const ExifTag_EXIF_TAG_INTER_COLOR_PROFILE: ExifTag = 34675;
pub const ExifTag_EXIF_TAG_EXPOSURE_PROGRAM: ExifTag = 34850;
pub const ExifTag_EXIF_TAG_SPECTRAL_SENSITIVITY: ExifTag = 34852;
pub const ExifTag_EXIF_TAG_GPS_INFO_IFD_POINTER: ExifTag = 34853;
pub const ExifTag_EXIF_TAG_ISO_SPEED_RATINGS: ExifTag = 34855;
pub const ExifTag_EXIF_TAG_OECF: ExifTag = 34856;
pub const ExifTag_EXIF_TAG_TIME_ZONE_OFFSET: ExifTag = 34858;
pub const ExifTag_EXIF_TAG_SENSITIVITY_TYPE: ExifTag = 34864;
pub const ExifTag_EXIF_TAG_STANDARD_OUTPUT_SENSITIVITY: ExifTag = 34865;
pub const ExifTag_EXIF_TAG_RECOMMENDED_EXPOSURE_INDEX: ExifTag = 34866;
pub const ExifTag_EXIF_TAG_ISO_SPEED: ExifTag = 34867;
pub const ExifTag_EXIF_TAG_ISO_SPEEDLatitudeYYY: ExifTag = 34868;
pub const ExifTag_EXIF_TAG_ISO_SPEEDLatitudeZZZ: ExifTag = 34869;
pub const ExifTag_EXIF_TAG_EXIF_VERSION: ExifTag = 36864;
pub const ExifTag_EXIF_TAG_DATE_TIME_ORIGINAL: ExifTag = 36867;
pub const ExifTag_EXIF_TAG_DATE_TIME_DIGITIZED: ExifTag = 36868;
pub const ExifTag_EXIF_TAG_OFFSET_TIME: ExifTag = 36880;
pub const ExifTag_EXIF_TAG_OFFSET_TIME_ORIGINAL: ExifTag = 36881;
pub const ExifTag_EXIF_TAG_OFFSET_TIME_DIGITIZED: ExifTag = 36882;
pub const ExifTag_EXIF_TAG_COMPONENTS_CONFIGURATION: ExifTag = 37121;
pub const ExifTag_EXIF_TAG_COMPRESSED_BITS_PER_PIXEL: ExifTag = 37122;
pub const ExifTag_EXIF_TAG_SHUTTER_SPEED_VALUE: ExifTag = 37377;
pub const ExifTag_EXIF_TAG_APERTURE_VALUE: ExifTag = 37378;
pub const ExifTag_EXIF_TAG_BRIGHTNESS_VALUE: ExifTag = 37379;
pub const ExifTag_EXIF_TAG_EXPOSURE_BIAS_VALUE: ExifTag = 37380;
pub const ExifTag_EXIF_TAG_MAX_APERTURE_VALUE: ExifTag = 37381;
pub const ExifTag_EXIF_TAG_SUBJECT_DISTANCE: ExifTag = 37382;
pub const ExifTag_EXIF_TAG_METERING_MODE: ExifTag = 37383;
pub const ExifTag_EXIF_TAG_LIGHT_SOURCE: ExifTag = 37384;
pub const ExifTag_EXIF_TAG_FLASH: ExifTag = 37385;
pub const ExifTag_EXIF_TAG_FOCAL_LENGTH: ExifTag = 37386;
pub const ExifTag_EXIF_TAG_SUBJECT_AREA: ExifTag = 37396;
pub const ExifTag_EXIF_TAG_TIFF_EP_STANDARD_ID: ExifTag = 37398;
pub const ExifTag_EXIF_TAG_MAKER_NOTE: ExifTag = 37500;
pub const ExifTag_EXIF_TAG_USER_COMMENT: ExifTag = 37510;
pub const ExifTag_EXIF_TAG_SUB_SEC_TIME: ExifTag = 37520;
pub const ExifTag_EXIF_TAG_SUB_SEC_TIME_ORIGINAL: ExifTag = 37521;
pub const ExifTag_EXIF_TAG_SUB_SEC_TIME_DIGITIZED: ExifTag = 37522;
pub const ExifTag_EXIF_TAG_XP_TITLE: ExifTag = 40091;
pub const ExifTag_EXIF_TAG_XP_COMMENT: ExifTag = 40092;
pub const ExifTag_EXIF_TAG_XP_AUTHOR: ExifTag = 40093;
pub const ExifTag_EXIF_TAG_XP_KEYWORDS: ExifTag = 40094;
pub const ExifTag_EXIF_TAG_XP_SUBJECT: ExifTag = 40095;
pub const ExifTag_EXIF_TAG_FLASH_PIX_VERSION: ExifTag = 40960;
pub const ExifTag_EXIF_TAG_COLOR_SPACE: ExifTag = 40961;
pub const ExifTag_EXIF_TAG_PIXEL_X_DIMENSION: ExifTag = 40962;
pub const ExifTag_EXIF_TAG_PIXEL_Y_DIMENSION: ExifTag = 40963;
pub const ExifTag_EXIF_TAG_RELATED_SOUND_FILE: ExifTag = 40964;
pub const ExifTag_EXIF_TAG_INTEROPERABILITY_IFD_POINTER: ExifTag = 40965;
pub const ExifTag_EXIF_TAG_FLASH_ENERGY: ExifTag = 41483;
pub const ExifTag_EXIF_TAG_SPATIAL_FREQUENCY_RESPONSE: ExifTag = 41484;
pub const ExifTag_EXIF_TAG_FOCAL_PLANE_X_RESOLUTION: ExifTag = 41486;
pub const ExifTag_EXIF_TAG_FOCAL_PLANE_Y_RESOLUTION: ExifTag = 41487;
pub const ExifTag_EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT: ExifTag = 41488;
pub const ExifTag_EXIF_TAG_SUBJECT_LOCATION: ExifTag = 41492;
pub const ExifTag_EXIF_TAG_EXPOSURE_INDEX: ExifTag = 41493;
pub const ExifTag_EXIF_TAG_SENSING_METHOD: ExifTag = 41495;
pub const ExifTag_EXIF_TAG_FILE_SOURCE: ExifTag = 41728;
pub const ExifTag_EXIF_TAG_SCENE_TYPE: ExifTag = 41729;
pub const ExifTag_EXIF_TAG_NEW_CFA_PATTERN: ExifTag = 41730;
pub const ExifTag_EXIF_TAG_CUSTOM_RENDERED: ExifTag = 41985;
pub const ExifTag_EXIF_TAG_EXPOSURE_MODE: ExifTag = 41986;
pub const ExifTag_EXIF_TAG_WHITE_BALANCE: ExifTag = 41987;
pub const ExifTag_EXIF_TAG_DIGITAL_ZOOM_RATIO: ExifTag = 41988;
pub const ExifTag_EXIF_TAG_FOCAL_LENGTH_IN_35MM_FILM: ExifTag = 41989;
pub const ExifTag_EXIF_TAG_SCENE_CAPTURE_TYPE: ExifTag = 41990;
pub const ExifTag_EXIF_TAG_GAIN_CONTROL: ExifTag = 41991;
pub const ExifTag_EXIF_TAG_CONTRAST: ExifTag = 41992;
pub const ExifTag_EXIF_TAG_SATURATION: ExifTag = 41993;
pub const ExifTag_EXIF_TAG_SHARPNESS: ExifTag = 41994;
pub const ExifTag_EXIF_TAG_DEVICE_SETTING_DESCRIPTION: ExifTag = 41995;
pub const ExifTag_EXIF_TAG_SUBJECT_DISTANCE_RANGE: ExifTag = 41996;
pub const ExifTag_EXIF_TAG_IMAGE_UNIQUE_ID: ExifTag = 42016;
pub const ExifTag_EXIF_TAG_CAMERA_OWNER_NAME: ExifTag = 42032;
pub const ExifTag_EXIF_TAG_BODY_SERIAL_NUMBER: ExifTag = 42033;
pub const ExifTag_EXIF_TAG_LENS_SPECIFICATION: ExifTag = 42034;
pub const ExifTag_EXIF_TAG_LENS_MAKE: ExifTag = 42035;
pub const ExifTag_EXIF_TAG_LENS_MODEL: ExifTag = 42036;
pub const ExifTag_EXIF_TAG_LENS_SERIAL_NUMBER: ExifTag = 42037;
pub const ExifTag_EXIF_TAG_COMPOSITE_IMAGE: ExifTag = 42080;
pub const ExifTag_EXIF_TAG_SOURCE_IMAGE_NUMBER_OF_COMPOSITE_IMAGE: ExifTag = 42081;
pub const ExifTag_EXIF_TAG_SOURCE_EXPOSURE_TIMES_OF_COMPOSITE_IMAGE: ExifTag = 42082;
pub const ExifTag_EXIF_TAG_GAMMA: ExifTag = 42240;
pub const ExifTag_EXIF_TAG_PRINT_IMAGE_MATCHING: ExifTag = 50341;
pub const ExifTag_EXIF_TAG_PADDING: ExifTag = 59932;
pub type ExifTag = ::std::os::raw::c_uint;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_UNKNOWN: ExifSupportLevel = 0;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_NOT_RECORDED: ExifSupportLevel = 1;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_MANDATORY: ExifSupportLevel = 2;
pub const ExifSupportLevel_EXIF_SUPPORT_LEVEL_OPTIONAL: ExifSupportLevel = 3;
pub type ExifSupportLevel = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_tag_from_name(name: *const ::std::os::raw::c_char) -> ExifTag;
}
extern "C" {
    pub fn exif_tag_get_name_in_ifd(tag: ExifTag, ifd: ExifIfd) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_title_in_ifd(tag: ExifTag, ifd: ExifIfd) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_description_in_ifd(
        tag: ExifTag,
        ifd: ExifIfd,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_support_level_in_ifd(
        tag: ExifTag,
        ifd: ExifIfd,
        t: ExifDataType,
    ) -> ExifSupportLevel;
}
extern "C" {
    pub fn exif_tag_get_name(tag: ExifTag) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_title(tag: ExifTag) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_get_description(tag: ExifTag) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_table_get_tag(n: ::std::os::raw::c_uint) -> ExifTag;
}
extern "C" {
    pub fn exif_tag_table_get_name(n: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_tag_table_count() -> ::std::os::raw::c_uint;
}
pub const ExifByteOrder_EXIF_BYTE_ORDER_MOTOROLA: ExifByteOrder = 0;
pub const ExifByteOrder_EXIF_BYTE_ORDER_INTEL: ExifByteOrder = 1;
pub type ExifByteOrder = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_byte_order_get_name(order: ExifByteOrder) -> *const ::std::os::raw::c_char;
}
pub const ExifFormat_EXIF_FORMAT_BYTE: ExifFormat = 1;
pub const ExifFormat_EXIF_FORMAT_ASCII: ExifFormat = 2;
pub const ExifFormat_EXIF_FORMAT_SHORT: ExifFormat = 3;
pub const ExifFormat_EXIF_FORMAT_LONG: ExifFormat = 4;
pub const ExifFormat_EXIF_FORMAT_RATIONAL: ExifFormat = 5;
pub const ExifFormat_EXIF_FORMAT_SBYTE: ExifFormat = 6;
pub const ExifFormat_EXIF_FORMAT_UNDEFINED: ExifFormat = 7;
pub const ExifFormat_EXIF_FORMAT_SSHORT: ExifFormat = 8;
pub const ExifFormat_EXIF_FORMAT_SLONG: ExifFormat = 9;
pub const ExifFormat_EXIF_FORMAT_SRATIONAL: ExifFormat = 10;
pub const ExifFormat_EXIF_FORMAT_FLOAT: ExifFormat = 11;
pub const ExifFormat_EXIF_FORMAT_DOUBLE: ExifFormat = 12;
pub type ExifFormat = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_format_get_name(format: ExifFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_format_get_size(format: ExifFormat) -> ::std::os::raw::c_uchar;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type ExifByte = ::std::os::raw::c_uchar;
pub type ExifSByte = ::std::os::raw::c_schar;
pub type ExifAscii = *mut ::std::os::raw::c_char;
pub type ExifShort = u16;
pub type ExifSShort = i16;
pub type ExifLong = u32;
pub type ExifSLong = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExifRational {
    pub numerator: ExifLong,
    pub denominator: ExifLong,
}
#[test]
fn bindgen_test_layout_ExifRational() {
    const UNINIT: ::std::mem::MaybeUninit<ExifRational> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ExifRational>(),
        8usize,
        concat!("Size of: ", stringify!(ExifRational))
    );
    assert_eq!(
        ::std::mem::align_of::<ExifRational>(),
        4usize,
        concat!("Alignment of ", stringify!(ExifRational))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifRational),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifRational),
            "::",
            stringify!(denominator)
        )
    );
}
pub type ExifUndefined = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExifSRational {
    pub numerator: ExifSLong,
    pub denominator: ExifSLong,
}
#[test]
fn bindgen_test_layout_ExifSRational() {
    const UNINIT: ::std::mem::MaybeUninit<ExifSRational> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ExifSRational>(),
        8usize,
        concat!("Size of: ", stringify!(ExifSRational))
    );
    assert_eq!(
        ::std::mem::align_of::<ExifSRational>(),
        4usize,
        concat!("Alignment of ", stringify!(ExifSRational))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifSRational),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ExifSRational),
            "::",
            stringify!(denominator)
        )
    );
}
extern "C" {
    pub fn exif_get_short(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifShort;
}
extern "C" {
    pub fn exif_get_sshort(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifSShort;
}
extern "C" {
    pub fn exif_get_long(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifLong;
}
extern "C" {
    pub fn exif_get_slong(b: *const ::std::os::raw::c_uchar, order: ExifByteOrder) -> ExifSLong;
}
extern "C" {
    pub fn exif_get_rational(
        b: *const ::std::os::raw::c_uchar,
        order: ExifByteOrder,
    ) -> ExifRational;
}
extern "C" {
    pub fn exif_get_srational(
        b: *const ::std::os::raw::c_uchar,
        order: ExifByteOrder,
    ) -> ExifSRational;
}
extern "C" {
    pub fn exif_set_short(b: *mut ::std::os::raw::c_uchar, order: ExifByteOrder, value: ExifShort);
}
extern "C" {
    pub fn exif_set_sshort(
        b: *mut ::std::os::raw::c_uchar,
        order: ExifByteOrder,
        value: ExifSShort,
    );
}
extern "C" {
    pub fn exif_set_long(b: *mut ::std::os::raw::c_uchar, order: ExifByteOrder, value: ExifLong);
}
extern "C" {
    pub fn exif_set_slong(b: *mut ::std::os::raw::c_uchar, order: ExifByteOrder, value: ExifSLong);
}
extern "C" {
    pub fn exif_set_rational(
        b: *mut ::std::os::raw::c_uchar,
        order: ExifByteOrder,
        value: ExifRational,
    );
}
extern "C" {
    pub fn exif_set_srational(
        b: *mut ::std::os::raw::c_uchar,
        order: ExifByteOrder,
        value: ExifSRational,
    );
}
extern "C" {
    pub fn exif_convert_utf16_to_utf8(
        out: *mut ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_uchar,
        maxlen: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exif_array_set_byte_order(
        arg1: ExifFormat,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_uint,
        o_orig: ExifByteOrder,
        o_new: ExifByteOrder,
    );
}
pub type ExifMemAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(s: ExifLong) -> *mut ::std::os::raw::c_void>;
pub type ExifMemReallocFunc = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut ::std::os::raw::c_void,
        s: ExifLong,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type ExifMemFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(p: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifMem {
    _unused: [u8; 0],
}
pub type ExifMem = _ExifMem;
extern "C" {
    pub fn exif_mem_new(
        a: ExifMemAllocFunc,
        r: ExifMemReallocFunc,
        f: ExifMemFreeFunc,
    ) -> *mut ExifMem;
}
extern "C" {
    pub fn exif_mem_ref(arg1: *mut ExifMem);
}
extern "C" {
    pub fn exif_mem_unref(arg1: *mut ExifMem);
}
extern "C" {
    pub fn exif_mem_alloc(m: *mut ExifMem, s: ExifLong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn exif_mem_realloc(
        m: *mut ExifMem,
        p: *mut ::std::os::raw::c_void,
        s: ExifLong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn exif_mem_free(m: *mut ExifMem, p: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn exif_mem_new_default() -> *mut ExifMem;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifLog {
    _unused: [u8; 0],
}
pub type ExifLog = _ExifLog;
extern "C" {
    pub fn exif_log_new() -> *mut ExifLog;
}
extern "C" {
    pub fn exif_log_new_mem(arg1: *mut ExifMem) -> *mut ExifLog;
}
extern "C" {
    pub fn exif_log_ref(log: *mut ExifLog);
}
extern "C" {
    pub fn exif_log_unref(log: *mut ExifLog);
}
extern "C" {
    pub fn exif_log_free(log: *mut ExifLog);
}
pub const ExifLogCode_EXIF_LOG_CODE_NONE: ExifLogCode = 0;
pub const ExifLogCode_EXIF_LOG_CODE_DEBUG: ExifLogCode = 1;
pub const ExifLogCode_EXIF_LOG_CODE_NO_MEMORY: ExifLogCode = 2;
pub const ExifLogCode_EXIF_LOG_CODE_CORRUPT_DATA: ExifLogCode = 3;
pub type ExifLogCode = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_log_code_get_title(code: ExifLogCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_log_code_get_message(code: ExifLogCode) -> *const ::std::os::raw::c_char;
}
pub type ExifLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log: *mut ExifLog,
        arg1: ExifLogCode,
        domain: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn exif_log_set_func(
        log: *mut ExifLog,
        func: ExifLogFunc,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn exif_log(
        log: *mut ExifLog,
        arg1: ExifLogCode,
        domain: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn exif_logv(
        log: *mut ExifLog,
        arg1: ExifLogCode,
        domain: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifMnoteData {
    _unused: [u8; 0],
}
pub type ExifMnoteData = _ExifMnoteData;
extern "C" {
    pub fn exif_mnote_data_ref(arg1: *mut ExifMnoteData);
}
extern "C" {
    pub fn exif_mnote_data_unref(arg1: *mut ExifMnoteData);
}
extern "C" {
    pub fn exif_mnote_data_load(
        d: *mut ExifMnoteData,
        buf: *const ::std::os::raw::c_uchar,
        buf_size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_mnote_data_save(
        d: *mut ExifMnoteData,
        buf: *mut *mut ::std::os::raw::c_uchar,
        buf_size: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_mnote_data_count(d: *mut ExifMnoteData) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn exif_mnote_data_get_id(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn exif_mnote_data_get_name(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_get_title(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_get_description(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_get_value(
        d: *mut ExifMnoteData,
        n: ::std::os::raw::c_uint,
        val: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_mnote_data_log(arg1: *mut ExifMnoteData, arg2: *mut ExifLog);
}
pub type ExifData = _ExifData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifDataPrivate {
    _unused: [u8; 0],
}
pub type ExifDataPrivate = _ExifDataPrivate;
pub type ExifContent = _ExifContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifContentPrivate {
    _unused: [u8; 0],
}
pub type ExifContentPrivate = _ExifContentPrivate;
pub type ExifEntry = _ExifEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifEntryPrivate {
    _unused: [u8; 0],
}
pub type ExifEntryPrivate = _ExifEntryPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifEntry {
    pub tag: ExifTag,
    pub format: ExifFormat,
    pub components: ::std::os::raw::c_ulong,
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
    pub parent: *mut ExifContent,
    pub priv_: *mut ExifEntryPrivate,
}
#[test]
fn bindgen_test_layout__ExifEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_ExifEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ExifEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_ExifEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_ExifEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_ExifEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).components) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifEntry),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn exif_entry_new() -> *mut ExifEntry;
}
extern "C" {
    pub fn exif_entry_new_mem(arg1: *mut ExifMem) -> *mut ExifEntry;
}
extern "C" {
    pub fn exif_entry_ref(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_unref(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_free(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_initialize(e: *mut ExifEntry, tag: ExifTag);
}
extern "C" {
    pub fn exif_entry_fix(entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_entry_get_value(
        entry: *mut ExifEntry,
        val: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_entry_dump(entry: *mut ExifEntry, indent: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifContent {
    pub entries: *mut *mut ExifEntry,
    pub count: ::std::os::raw::c_uint,
    pub parent: *mut ExifData,
    pub priv_: *mut ExifContentPrivate,
}
#[test]
fn bindgen_test_layout__ExifContent() {
    const UNINIT: ::std::mem::MaybeUninit<_ExifContent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ExifContent>(),
        32usize,
        concat!("Size of: ", stringify!(_ExifContent))
    );
    assert_eq!(
        ::std::mem::align_of::<_ExifContent>(),
        8usize,
        concat!("Alignment of ", stringify!(_ExifContent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifContent),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn exif_content_new() -> *mut ExifContent;
}
extern "C" {
    pub fn exif_content_new_mem(arg1: *mut ExifMem) -> *mut ExifContent;
}
extern "C" {
    pub fn exif_content_ref(content: *mut ExifContent);
}
extern "C" {
    pub fn exif_content_unref(content: *mut ExifContent);
}
extern "C" {
    pub fn exif_content_free(content: *mut ExifContent);
}
extern "C" {
    pub fn exif_content_add_entry(c: *mut ExifContent, entry: *mut ExifEntry);
}
extern "C" {
    pub fn exif_content_remove_entry(c: *mut ExifContent, e: *mut ExifEntry);
}
extern "C" {
    pub fn exif_content_get_entry(content: *mut ExifContent, tag: ExifTag) -> *mut ExifEntry;
}
extern "C" {
    pub fn exif_content_fix(c: *mut ExifContent);
}
pub type ExifContentForeachEntryFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ExifEntry, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn exif_content_foreach_entry(
        content: *mut ExifContent,
        func: ExifContentForeachEntryFunc,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn exif_content_get_ifd(c: *mut ExifContent) -> ExifIfd;
}
extern "C" {
    pub fn exif_content_dump(content: *mut ExifContent, indent: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn exif_content_log(content: *mut ExifContent, log: *mut ExifLog);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifData {
    pub ifd: [*mut ExifContent; 5usize],
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
    pub priv_: *mut ExifDataPrivate,
}
#[test]
fn bindgen_test_layout__ExifData() {
    const UNINIT: ::std::mem::MaybeUninit<_ExifData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ExifData>(),
        64usize,
        concat!("Size of: ", stringify!(_ExifData))
    );
    assert_eq!(
        ::std::mem::align_of::<_ExifData>(),
        8usize,
        concat!("Alignment of ", stringify!(_ExifData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(ifd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ExifData),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn exif_data_new() -> *mut ExifData;
}
extern "C" {
    pub fn exif_data_new_mem(arg1: *mut ExifMem) -> *mut ExifData;
}
extern "C" {
    pub fn exif_data_new_from_file(path: *const ::std::os::raw::c_char) -> *mut ExifData;
}
extern "C" {
    pub fn exif_data_new_from_data(
        data: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_uint,
    ) -> *mut ExifData;
}
extern "C" {
    pub fn exif_data_load_data(
        data: *mut ExifData,
        d: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_data_save_data(
        data: *mut ExifData,
        d: *mut *mut ::std::os::raw::c_uchar,
        ds: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_data_ref(data: *mut ExifData);
}
extern "C" {
    pub fn exif_data_unref(data: *mut ExifData);
}
extern "C" {
    pub fn exif_data_free(data: *mut ExifData);
}
extern "C" {
    pub fn exif_data_get_byte_order(data: *mut ExifData) -> ExifByteOrder;
}
extern "C" {
    pub fn exif_data_set_byte_order(data: *mut ExifData, order: ExifByteOrder);
}
extern "C" {
    pub fn exif_data_get_mnote_data(d: *mut ExifData) -> *mut ExifMnoteData;
}
extern "C" {
    pub fn exif_data_fix(d: *mut ExifData);
}
pub type ExifDataForeachContentFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ExifContent, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn exif_data_foreach_content(
        data: *mut ExifData,
        func: ExifDataForeachContentFunc,
        user_data: *mut ::std::os::raw::c_void,
    );
}
pub const ExifDataOption_EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS: ExifDataOption = 1;
pub const ExifDataOption_EXIF_DATA_OPTION_FOLLOW_SPECIFICATION: ExifDataOption = 2;
pub const ExifDataOption_EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE: ExifDataOption = 4;
pub type ExifDataOption = ::std::os::raw::c_uint;
extern "C" {
    pub fn exif_data_option_get_name(o: ExifDataOption) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_data_option_get_description(o: ExifDataOption) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn exif_data_set_option(d: *mut ExifData, o: ExifDataOption);
}
extern "C" {
    pub fn exif_data_unset_option(d: *mut ExifData, o: ExifDataOption);
}
extern "C" {
    pub fn exif_data_set_data_type(d: *mut ExifData, dt: ExifDataType);
}
extern "C" {
    pub fn exif_data_get_data_type(d: *mut ExifData) -> ExifDataType;
}
extern "C" {
    pub fn exif_data_dump(data: *mut ExifData);
}
extern "C" {
    pub fn exif_data_log(data: *mut ExifData, log: *mut ExifLog);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ExifLoader {
    _unused: [u8; 0],
}
pub type ExifLoader = _ExifLoader;
extern "C" {
    pub fn exif_loader_new() -> *mut ExifLoader;
}
extern "C" {
    pub fn exif_loader_new_mem(mem: *mut ExifMem) -> *mut ExifLoader;
}
extern "C" {
    pub fn exif_loader_ref(loader: *mut ExifLoader);
}
extern "C" {
    pub fn exif_loader_unref(loader: *mut ExifLoader);
}
extern "C" {
    pub fn exif_loader_write_file(loader: *mut ExifLoader, fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn exif_loader_write(
        loader: *mut ExifLoader,
        buf: *mut ::std::os::raw::c_uchar,
        sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn exif_loader_reset(loader: *mut ExifLoader);
}
extern "C" {
    pub fn exif_loader_get_data(loader: *mut ExifLoader) -> *mut ExifData;
}
extern "C" {
    pub fn exif_loader_get_buf(
        loader: *mut ExifLoader,
        buf: *mut *const ::std::os::raw::c_uchar,
        buf_size: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn exif_loader_log(loader: *mut ExifLoader, log: *mut ExifLog);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
